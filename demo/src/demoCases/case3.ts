import {CredentialSigner, CredentialVerifier, JolocomLib, IdentityWallet } from 'jolocom-lib'
import assert from 'assert'

// Example data structure generated by this library
const JSON_CREDENTIAL_WITH_PROOF = {
  credentialSubject: { email: 'example@mail.com', id: 'did:example:subject' },
  '@context': [
    'https://www.w3.org/2018/credentials/v1',
    {
      ProofOfEmailCredential:
        'https://identity.jolocom.com/terms/ProofOfEmailCredential',
      schema: 'http://schema.org/',
      email: 'schema:email',
    },
  ],
  id: 'claimId:e64233e4f71ca107',
  issuer: 'did:jun:E9owvpwvhd59r32LMajuxqgTUZffqU9qxH4GN3jokf5s',
  issuanceDate: '2022-02-02T10:21:49Z',
  expirationDate: '2023-02-02T10:21:49Z',
  type: ['VerifiableCredential', 'ProofOfEmailCredential'],
  proof: [
    {
      proofPurpose: 'assertionMethod',
      created: '2022-02-02T10:21:49Z',
      type: 'Ed25519Signature2018',
      jws:
        'eyJhbGciOiJFZERTQSIsImI2NCI6ZmFsc2UsImNyaXQiOlsiYjY0Il19..Ky1aNIp24YnPg5qXfoEMdzDgsEc05oPoDV22-tq8_vXDWz6shqOOGCkewCMSf0ZD1C6V5walkOvRZGA7B1QdCQ',
      verificationMethod:
        'did:jun:E9owvpwvhd59r32LMajuxqgTUZffqU9qxH4GN3jokf5s#D2UI8qsT_W3L_zHZeMOJt2LzjK-Z2KhBrYKjGEW-q6d8',
    },
  ],
}
// Case 3. A VC with existing proofs is received as JSON, new signature is added, the VC is tampered with, verification should fail.
export const case3 = async (signer: IdentityWallet, pass: string, verifier: CredentialVerifier, renderReports = false) => {
  console.group()
  const credentialSigner = CredentialSigner.fromSignedCredential(
    JSON_CREDENTIAL_WITH_PROOF
  )

  const p1 = credentialSigner.proofs[0]

  const p2 = await credentialSigner.generateProof(
    JolocomLib.LinkedDataProofTypes.ChainedProof2021,
    {
      proofOptions: {
        verificationMethod: signer.publicKeyMetadata.signingKeyId,
      },
      proofSpecificOptions: {
        chainSignatureSuite: JolocomLib.LinkedDataProofTypes.Ed25519Signature2018,
        previousProof: {
          verificationMethod: p1.verificationMethod,
          created: p1.created,
          proofPurpose: p1.proofPurpose,
          type: p1.proofType,
        },
      },
    },
    signer,
    pass
  )

  await wait(1)

  await credentialSigner.generateProof(
    JolocomLib.LinkedDataProofTypes.ChainedProof2021,
    {
      proofOptions: {
        verificationMethod: signer.publicKeyMetadata.signingKeyId,
      },
      proofSpecificOptions: {
        chainSignatureSuite: JolocomLib.LinkedDataProofTypes.Ed25519Signature2018,
        previousProof: {
          verificationMethod: p2.verificationMethod,
          created: p2.created,
          proofPurpose: p2.proofPurpose,
          type: p2.proofType,
        },
      },
    },
    signer,
    pass
  )

  // Render the assembled VC, should contain the original VC and proof, and the newly created proof.
  const finalCredential = credentialSigner.toSignedCredential()
  const {proof, ...rest} = finalCredential.toJSON()

  console.log('Signed Credential with newly added proofs:')
  console.group()
  console.log(rest)
  console.groupEnd()
  console.log('Proofs associated with the credential:')
  console.group()
  console.log(proof)
  console.groupEnd()

  const verificationResults = await verifier.generateVerificationReport(finalCredential)

  if (renderReports) {
    console.log('Verification results, if the signed contents are not modified:')
    console.group()
    Object.values(verificationResults).forEach((v, i) => {
      console.log(`Signature at index ${i}`)
      console.log(v)
    })
    console.groupEnd()
  }

  // Assert all signatures are valid, the content was not modified
  assert(await verifier.verifyProofs(finalCredential), 'All proofs should verify correctly')

  console.log()
  console.log('Modifying the VC subject field.')
  console.log()
  // Alter the credential, should lead to p1 being invalid.
  // finalCredential.credentialSubject.id = 'did:malicious:attacker'
  // Further possible alterations, e.g. to the proofs themselves.
  // @ts-ignore accessing private property
  finalCredential.proof[1]._proofValue = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..t3VhQ7QsILDuV_HNFSMI-Fb2FoT7fuzalpS5AH8A9c0"
  // finalCredential.proof[1].created = new Date()
  // finalCredential.proof[1].proofPurpose = 'capabilityInvocation'

  const alteredVerificationResults = await verifier.generateVerificationReport(finalCredential)

  if (renderReports) {
    console.log('Verification results after the signed contents were modified:')
    console.group()
    Object.values(alteredVerificationResults).forEach((v, i) => {
      console.log(`Signature at index ${i}`)
      console.log(v)
    })
    console.groupEnd()
  }
  assert(await verifier.verifyProofs(finalCredential) === false, 'Verification should fail')
  assert(alteredVerificationResults[0].valid)
  assert(alteredVerificationResults[1].valid === false)
  assert(
    alteredVerificationResults[1].proofMetadata.referencedProofValid === true
  )
  assert(alteredVerificationResults[2].valid)
  assert(alteredVerificationResults[2].proofMetadata.referencedProofValid === false)

  console.groupEnd()
}

const wait = (duration = 1) => {
  return new Promise((resolve) => {
    setTimeout(() => resolve(undefined), duration * 1000)
  })
}
