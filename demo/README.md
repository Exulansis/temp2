## Readme

This repository includes a number of demo files, showcasing the usage of the Jolocom library for creating and verifying Linked Data Proofs of the `ChainedProof2021` type.

### Demo Cases
The demo code includes a number of assertions, helping test that the implementation works as intended, and that the produced outputs / examples are valid. The general scope of the demo files is:
- Case 1 -- The Jolocom Library (more specifically, the `CredentialSigner` abstraction) is used to create a new Verifiable Credential from scratch. Two proofs (generated by the same signer) are added to the newly created Verifiable Credential (i.e. a `Ed25519Signature2018` and `ChainedProof2021` proof node). The signatures are expected to be valid, and verified using the `verifyProofs` method exposed by the `CredentialVerifier` abstraction.

    After the signatures are verified, the contents of the Verifiable Credential are modified, and the signature verification process is repeated. At this point, the signature verification should fail as expected.

- Case 2 -- The Jolocom Library (more specifically, the `CredentialSigner` abstraction) is used to parse an example Verifiable Credential from JSON. Two proofs (generated by two different signers) are added to the newly created Verifiable Credential (i.e. a `Ed25519Signature2018` and `ChainedProof2021` proof node). The signatures are expected to be valid, and verified using the `verifyProofs` method exposed by the `CredentialVerifier` abstraction.

- Case 3 -- The Jolocom Library (more specifically, the `CredentialSigner` abstraction) is used to parse an example Verifiable Credential (with an existing proof node) from JSON. Two proofs, both of the `ChainedProof2021` (building on the original proof included in the JSON document) are added to the newly created Verifiable Credential. The signatures are expected to be valid, and verified using the `verifyProofs` method exposed by the `CredentialVerifier` abstraction.

    After the signatures are verified, the contents of the Verifiable Credential are modified, and the signature verification process is repeated. At this point, the signature verification should fail as expected.

### Running the demo cases:

In order to run all the demo cases, you can simply clone this repository, run `yarn install`, and then run `yarn demo`. A version of Jolocom-Lib which supports the new proof type is required (e.g. this [branch of our the Jolocom Library](https://github.com/jolocom/jolocom-lib/tree/feat/chained_proof)). Two Dockerfiles which can aid in running the demo are also provided in the corresponding folder.

### Data model compliance

In addition to the aforementioned usage examples, an additional set of data model compliance tests are included as well. The main goal of theses tests is to help ensure that Verifiable Credentials created by this library comply with version 1.1 of the specification.

This functionality is tested in two ways:
- A new Verifiable Credential is created using the Jolocom Library. We then assert that all required properties are included, and that corresponding normative statements are respected (e.g. `id` is present and an URI, `@context` is present and includes the required values, etc).
The test helps ensure that all properties on the newly generated VC are correctly named, and have the expected format.
- A small set of "round-trip" tests is defined as well. As part of these tests, the Jolocom Library is used to parse a number example JSON Verifiable Credential data structures (defined as part of the [W3C VC test suite](https://github.com/w3c/vc-test-suite/tree/gh-pages/test/vc-data-model-1.0/input)) and serialize them back to JSON. The output is then compared with the original test vector. These tests help ensure that our implementation supports the various properties (and the associated formats) defined by the spec, and that no data is lost / modified during such conversions.